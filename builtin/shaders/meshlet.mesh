#version 460 core
#extension GL_EXT_mesh_shader : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8: require // uint8_t for meshlet triangle indices

#include "lib/bda_vertex.glsl"
#include "resources/camera_block.glsl"

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = 64, max_primitives = 126) out;

struct Meshlet {
    uint vertexOffset;
    uint vertexCount;
	uint triangleOffset;
    uint triangleCount;

    uint materialIndex;
	uint padding0; // ensure 16-byte alignment
	uint padding1; // ensure 16-byte alignment
	uint padding2; // ensure 16-byte alignment

    vec3 center;
    float radius;
};

layout(buffer_reference, scalar) buffer MeshletBuffer { Meshlet meshlets[]; };
layout(buffer_reference, scalar) buffer MeshletVertexBuffer { uint meshletVertices[]; };
layout(buffer_reference, scalar) buffer MeshletTriangleBuffer { uint8_t meshletTriangles[]; };

layout(push_constant) uniform GlobalMeshDataPushConstants {
	uint64_t vertexBufferAddress;
    uint64_t meshletBufferAddress;
    uint64_t meshletVertexBufferAddress;
    uint64_t meshletTriangleBufferAddress;

    uint meshletCount;
	uint enableNormalMapping;
	uint padding0;
	uint padding1;

    mat4 modelMatrix;
} g_Mesh;

out PerVertex {
    layout(location = 0) flat uint meshletID;
    layout(location = 1) flat uint materialIndex;
    layout(location = 2) vec3 fragPos;
    layout(location = 3) vec2 texCoord;
    layout(location = 4) mat3 tbn;
} VSOut[];

const uint TASK_WORKGROUP_SIZE = 32;
struct TaskPayload
{
	uint meshletInstanceIDs[TASK_WORKGROUP_SIZE];
};
taskPayloadSharedEXT TaskPayload payload;

void main() {
    // uint meshletID = payload.meshletInstanceIDs[gl_WorkGroupID.x % TASK_WORKGROUP_SIZE];
	uint meshletID = gl_WorkGroupID.x;
	if (meshletID >= g_Mesh.meshletCount)
        return;

    // Resolve buffer references
    MeshletBuffer meshletBuf = MeshletBuffer(g_Mesh.meshletBufferAddress);
    MeshletVertexBuffer meshletVertBuf = MeshletVertexBuffer(g_Mesh.meshletVertexBufferAddress);
    MeshletTriangleBuffer meshletTriBuf = MeshletTriangleBuffer(g_Mesh.meshletTriangleBufferAddress);
    VertexBuffer vertexBuf = VertexBuffer(g_Mesh.vertexBufferAddress);

    Meshlet m = meshletBuf.meshlets[meshletID];
    SetMeshOutputsEXT(m.vertexCount, m.triangleCount);

    // Emit vertices
    for (uint i = gl_LocalInvocationIndex; i < m.vertexCount; i += gl_WorkGroupSize.x) {
        uint vIndex = meshletVertBuf.meshletVertices[m.vertexOffset + i];
        Vertex v = vertexBuf.vertices[vIndex];

        vec3 fragPos = vec3(g_Mesh.modelMatrix * vec4(v.position, 1.0));
        mat3 normalMatrix = transpose(inverse(mat3(g_Mesh.modelMatrix)));
        vec3 T = normalize(normalMatrix * v.tangent.xyz);
        vec3 N = normalize(normalMatrix * v.normal);
        T = normalize(T - dot(T, N) * N); // Gram-Schmidt orthogonalize
        vec3 B = cross(N, T) * v.tangent.w;
        mat3 TBN = mat3(T, B, N);
        gl_MeshVerticesEXT[i].gl_Position = u_Camera.viewProjection * vec4(fragPos, 1.0);

        VSOut[i].meshletID = meshletID;
        VSOut[i].materialIndex = m.materialIndex;
        VSOut[i].fragPos = fragPos;
        VSOut[i].texCoord = v.texCoord;
        VSOut[i].tbn = TBN;
    }

	// Emit triangles
    for (uint i = gl_LocalInvocationIndex; i < m.triangleCount; i += gl_WorkGroupSize.x) {
        uint base = m.triangleOffset + i * 3;
        uvec3 tri = uvec3(
            meshletTriBuf.meshletTriangles[base + 0],
            meshletTriBuf.meshletTriangles[base + 1],
            meshletTriBuf.meshletTriangles[base + 2]
        );
        gl_PrimitiveTriangleIndicesEXT[i] = tri;
    }
}
