#version 460 core

#include "lib/cubemap.glsl"
#include "lib/importance_sampling.glsl"
#include "lib/pbr.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 6) in;

layout(set = 0, binding = 0) uniform samplerCube environmentMap;
layout(set = 0, binding = 1, rgba16f) writeonly uniform imageCube prefilteredMap[5];

layout(push_constant) uniform PushConstants {
    uint  mipLevel;
    float roughness;
    uint  sampleCount;
} pc;

vec3 prefilterEnvMap(vec3 N, uint width) {
    vec3 color = vec3(0.0);
    float weight = 0.0;

    const uint kNumSamples = 1024;
    for (uint i = 0; i < kNumSamples; ++i) {
        vec2 Xi = hammersley2d(i, pc.sampleCount);
        const vec4 importanceSample = importanceSampleGGX(Xi, N, N, pc.roughness); // Using N as V

        const vec3 H = vec3(importanceSample);
        const float pdf = importanceSample.w;

        // mipmap filtered samples (GPU Gems 3, 20.4)
        float lod = computeLod(pdf, width, kNumSamples);

        // Note: reflect takes incident vector.
        vec3 V = N;
        vec3 L = normalize(reflect(-V, H));
        float NdotL = dot(N, L);

        if (NdotL > 0.0) {
            const vec3 sampleColor = textureLod(environmentMap, L, lod).rgb;
            color += sampleColor * NdotL;
            weight += NdotL;
        }
    }
    return color / (weight != 0.0 ? weight : float(kNumSamples));
}

void main() {
    const uint mipImageSize = imageSize(prefilteredMap[pc.mipLevel]).x;
    const ivec3 coord = ivec3(gl_GlobalInvocationID.xyz);
    if (coord.x >= mipImageSize || coord.y >= mipImageSize) return;

    vec3 N = normalize(cubeCoordToWorld(coord, mipImageSize));
    // N.y = -N.y;
    const uint width = textureSize(environmentMap, 0).x;
    const vec3 color = prefilterEnvMap(N, width);
    imageStore(prefilteredMap[pc.mipLevel], coord, vec4(color, 1.0));
}