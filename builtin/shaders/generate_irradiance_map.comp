#version 460 core

#include "lib/cubemap.glsl"
#include "lib/importance_sampling.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 6) in;

layout(set = 0, binding = 0) uniform samplerCube environmentMap;
layout(set = 0, binding = 1, rgba16f) writeonly uniform imageCube irradianceMap;

layout(push_constant) uniform PushConstants {
    float lodBias;
} pc;

vec3 integrateDiffuseIrradiance(vec3 N, uint envWidth) {
    vec3 color = vec3(0.0);

    const uint kNumSamples = 2048u; // high sample count for convergence
    for (uint i = 0u; i < kNumSamples; ++i) {
        // Importance sample over cosine-weighted hemisphere
        vec2 Xi = hammersley2d(i, kNumSamples);
        vec4 importanceSample = importanceSampleLambertian(Xi, N);
        vec3 L = importanceSample.xyz;
        float pdf = importanceSample.w;

        // Convert pdf to mip level
        float lod = computeLod(pdf, envWidth, kNumSamples);
        lod += pc.lodBias;

        vec3 sampleColor = textureLod(environmentMap, L, lod).rgb;
        color += sampleColor;
    }

    return color / float(kNumSamples);
}

void main() {
    ivec3 gid = ivec3(gl_GlobalInvocationID.xyz);
    ivec2 size = imageSize(irradianceMap);
    if (gid.x >= size.x || gid.y >= size.y || gid.z >= 6) return;

    vec2 uv = (vec2(gid.xy) + 0.5) / vec2(size.xy);
    vec3 N = directionFromCubeUV(gid.z, uv);
    uint envWidth = textureSize(environmentMap, 0).x;

    vec3 irradiance = integrateDiffuseIrradiance(N, envWidth);
    imageStore(irradianceMap, gid, vec4(irradiance, 1.0));
}