#version 460 core
#extension GL_EXT_mesh_shader : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8: require // uint8_t for meshlet triangle indices

#include "lib/bda_vertex.glsl"
#include "resources/camera_block.glsl"
#include "shader_config.hpp"

layout(local_size_x = MESH_WORK_GROUP_SIZE_X, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = MAX_MESHLET_VERTICES, max_primitives = MAX_MESHLET_TRIANGLES) out;

struct Meshlet {
    uint vertexOffset;
    uint vertexCount;
	uint triangleOffset;
    uint triangleCount;

    uint materialIndex;
	uint paddingU0; // ensure 16-byte alignment
	uint paddingU1; // ensure 16-byte alignment
	uint paddingU2; // ensure 16-byte alignment

    vec3 center;
    float radius;

	vec3 coneAxis;
	float coneCutoff; // cosine of the cone cutoff angle

	vec3 coneApex;
    float paddingF0; // ensure 16-byte alignment
};

layout(buffer_reference, scalar) buffer MeshletBuffer { Meshlet meshlets[]; };
layout(buffer_reference, scalar) buffer MeshletVertexBuffer { uint meshletVertices[]; };
layout(buffer_reference, scalar) buffer MeshletTriangleBuffer { uint8_t meshletTriangles[]; };

#include "resources/global_meshlet_data.glsl"

struct TaskPayload
{
	uint visibleMeshletIndices[TASK_WORK_GROUP_SIZE_X];
	uint visibleMeshletCount;
};
taskPayloadSharedEXT TaskPayload payload;

void main() {
#if USE_TASK_SHADER
	if (gl_WorkGroupID.x >= payload.visibleMeshletCount)
		return;

    uint meshletID = payload.visibleMeshletIndices[gl_WorkGroupID.x];
#else
    uint meshletID = gl_WorkGroupID.x;
    if (meshletID >= g_Mesh.meshletCount)
        return;
#endif

    // Resolve buffer references
    MeshletBuffer meshletBuf = MeshletBuffer(g_Mesh.meshletBufferAddress);
    MeshletVertexBuffer meshletVertBuf = MeshletVertexBuffer(g_Mesh.meshletVertexBufferAddress);
    MeshletTriangleBuffer meshletTriBuf = MeshletTriangleBuffer(g_Mesh.meshletTriangleBufferAddress);
    VertexBuffer vertexBuf = VertexBuffer(g_Mesh.vertexBufferAddress);

    Meshlet m = meshletBuf.meshlets[meshletID];
    SetMeshOutputsEXT(m.vertexCount, m.triangleCount);

    // Emit vertices
    for (uint i = gl_LocalInvocationIndex; i < m.vertexCount; i += gl_WorkGroupSize.x) {
        uint vIndex = meshletVertBuf.meshletVertices[m.vertexOffset + i];
        Vertex v = vertexBuf.vertices[vIndex];

        vec3 fragPos = vec3(g_Mesh.modelMatrix * vec4(v.position, 1.0));
        gl_MeshVerticesEXT[i].gl_Position = u_Camera.viewProjection * vec4(fragPos, 1.0);
    }

	// Emit triangles
    for (uint i = gl_LocalInvocationIndex; i < m.triangleCount; i += gl_WorkGroupSize.x) {
        uint base = m.triangleOffset + i * 3;
        uvec3 tri = uvec3(
            meshletTriBuf.meshletTriangles[base + 0],
            meshletTriBuf.meshletTriangles[base + 1],
            meshletTriBuf.meshletTriangles[base + 2]
        );
        gl_PrimitiveTriangleIndicesEXT[i] = tri;
    }
}
