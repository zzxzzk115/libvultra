#version 460 core
#extension GL_EXT_mesh_shader : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_scalar_block_layout : require

#include "resources/camera_block.glsl"

const uint TASK_WORKGROUP_SIZE = 32;
layout(local_size_x = TASK_WORKGROUP_SIZE) in;

struct Meshlet {
    uint vertexOffset;
    uint vertexCount;
	uint triangleOffset;
    uint triangleCount;

    uint materialIndex;
	uint paddingU0; // ensure 16-byte alignment
	uint paddingU1; // ensure 16-byte alignment
	uint paddingU2; // ensure 16-byte alignment

    vec3 center;
    float radius;

	vec3 coneAxis;
	float coneCutoff; // cosine of the cone cutoff angle

	vec3 coneApex;
    float paddingF0; // ensure 16-byte alignment
};

layout(buffer_reference, scalar) buffer MeshletBuffer { Meshlet meshlets[]; };

struct GPUMaterial {
    // --- texture indices ---
    uint albedoIndex;
    uint alphaMaskIndex;
    uint metallicIndex;
    uint roughnessIndex;

    uint specularIndex;
    uint normalIndex;
    uint aoIndex;
    uint emissiveIndex;

    uint metallicRoughnessIndex;
    uint paddingUI0; // ensure 16-byte alignment
    uint paddingUI1; // ensure 16-byte alignment
    uint paddingUI2; // ensure 16-byte alignment

    // --- color vectors ---
    vec4 baseColor;
    vec4 emissiveColorIntensity;
    vec4 ambientColor;

    // --- scalar material params ---
    float opacity;
    float metallicFactor;
    float roughnessFactor;
    float ior;

    float alphaCutoff;
    float paddingF0; // ensure 16-byte alignment
    float paddingF1; // ensure 16-byte alignment
    float paddingF2; // ensure 16-byte alignment

    // --- int params ---
    int alphaMode; // 0: OPAQUE, 1: MASK, 2: BLEND
    int doubleSided;
    int paddingI0; // ensure 16-byte alignment
    int paddingI1; // ensure 16-byte alignment
};
layout(std430, set = 2, binding = 0) readonly buffer Materials {
    GPUMaterial materials[];
};

layout(push_constant) uniform GlobalMeshDataPushConstants {
	uint64_t vertexBufferAddress;
    uint64_t meshletBufferAddress;
    uint64_t meshletVertexBufferAddress;
    uint64_t meshletTriangleBufferAddress;

    uint meshletCount;
	uint enableNormalMapping;
	uint debugMode; // 0: meshlet ID, 1: material index
	uint padding1;

	mat4 modelMatrix;
} g_Mesh;

struct TaskPayload
{
	uint visibleMeshletIndices[TASK_WORKGROUP_SIZE];
	uint visibleMeshletCount;
};
taskPayloadSharedEXT TaskPayload payload;

bool isInsideFrustum(vec3 center, float radius) {
    for (int i = 0; i < 6; ++i) {
        vec4 plane = u_Camera.frustumPlanes[i];
        float d = dot(plane.xyz, center) + plane.w;
        if (d < -radius)
            return false; // outside the frustum
    }
    return true;
}

// https://github.com/zeux/meshoptimizer/tree/v0.24?tab=readme-ov-file#mesh-shading
// Not used currently
bool isVisibleByCone(vec3 coneApex, vec3 coneAxis, float coneCutoff, vec3 cameraPos) {
    return dot(normalize(coneApex - cameraPos), coneAxis) < coneCutoff;
}

// Alternative cone culling method inspired by Alan Wake 2 tech talk
bool isVisibleByConeAlanWake2(vec3 coneAxis, float coneCutoff, vec3 center, float radius, vec3 cameraPos) {
	vec3 boundingSphereDir = center - cameraPos;
	float boundingSphereDistance = length(boundingSphereDir);
	float cutOff = coneCutoff + boundingSphereDistance + radius;
	return dot(boundingSphereDir, coneAxis) < cutOff;
}

void main()
{
	uint idx = gl_WorkGroupID.x * TASK_WORKGROUP_SIZE + gl_LocalInvocationIndex;
	if (idx >= g_Mesh.meshletCount)
		return;

    if(gl_LocalInvocationIndex == 0) {
        payload.visibleMeshletCount = 0;
    }
	barrier();

	// Resolve meshlet buffer
	MeshletBuffer meshletBuf = MeshletBuffer(g_Mesh.meshletBufferAddress);

	// Get meshlet
	Meshlet meshlet = meshletBuf.meshlets[idx];
	vec3 center = (g_Mesh.modelMatrix * vec4(meshlet.center, 1.0)).xyz;
	float radius = meshlet.radius;

	// Frustum culling
	bool frustumVisible = isInsideFrustum(center, radius);

	// Cone culling for backface elimination
	bool coneVisible = false;
	GPUMaterial material = materials[meshlet.materialIndex];
	// Only perform cone culling for single-sided materials with a valid coneCutoff
	if (meshlet.coneCutoff < 1.0 && material.doubleSided == 0) {
		vec3 coneAxis = normalize((g_Mesh.modelMatrix * vec4(meshlet.coneAxis, 0.0)).xyz);
		coneVisible = isVisibleByConeAlanWake2(coneAxis, meshlet.coneCutoff, center, radius, getCameraPosition());
	} else {
		coneVisible = true;
	}

	if (frustumVisible && coneVisible) {
		uint index = atomicAdd(payload.visibleMeshletCount, 1);
		payload.visibleMeshletIndices[index] = idx;
	}

	barrier();
	if (gl_LocalInvocationIndex == 0 && payload.visibleMeshletCount > 0) {
		EmitMeshTasksEXT(payload.visibleMeshletCount, 1, 1);
	}
}