#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : require

#include "lib/bda_vertex.glsl"

layout(set = 3, binding = 0) uniform accelerationStructureEXT topLevelAS;

struct GPUInstanceData {
    uint geometryOffset;
    uint geometryCount;
    uint materialOffset;
    uint materialCount;
};
layout(std430, set = 2, binding = 0) buffer InstanceData { GPUInstanceData instances[]; };

struct GPUMaterial {
    // --- texture indices ---
    uint albedoIndex;
    uint alphaMaskIndex;
    uint metallicIndex;
    uint roughnessIndex;

    uint specularIndex;
    uint normalIndex;
    uint aoIndex;
    uint emissiveIndex;

    uint metallicRoughnessIndex;
    uint paddingUI0; // ensure 16-byte alignment
    uint paddingUI1; // ensure 16-byte alignment
    uint paddingUI2; // ensure 16-byte alignment

    // --- color vectors ---
    vec4 baseColor;
    vec4 emissiveColorIntensity;
    vec4 ambientColor;

    // --- scalar material params ---
    float opacity;
    float metallicFactor;
    float roughnessFactor;
    float ior;

    float alphaCutoff;
    float paddingF0; // ensure 16-byte alignment
    float paddingF1; // ensure 16-byte alignment
    float paddingF2; // ensure 16-byte alignment

    // --- int params ---
    int alphaMode; // 0: OPAQUE, 1: MASK, 2: BLEND
    int doubleSided;
    int paddingI0; // ensure 16-byte alignment
    int paddingI1; // ensure 16-byte alignment
};
layout(std430, set = 2, binding = 1) buffer Materials { GPUMaterial materials[]; };

struct GPUGeometryNode {
    uint64_t vertexBufferAddress;
    uint64_t indexBufferAddress;
    uint materialIndex;
};
layout(std430, set = 2, binding = 2) buffer GeometryNodes { GPUGeometryNode geometryNodes[]; };

layout(set = 2, binding = 3) uniform sampler2D textures[];

hitAttributeEXT vec2 attribs;

void main()
{
    const uint instanceIndex = gl_InstanceCustomIndexEXT;
    GPUInstanceData instance = instances[nonuniformEXT(instanceIndex)];

	const uint geomIndex = gl_GeometryIndexEXT;
    const uint geomGlobalIndex = instance.geometryOffset + geomIndex;
    GPUGeometryNode node = geometryNodes[nonuniformEXT(geomGlobalIndex)];

    const uint materialIndex = node.materialIndex;
    const uint materialGlobalIndex = instance.materialOffset + materialIndex;
    GPUMaterial mat = materials[nonuniformEXT(materialGlobalIndex)];

	Vertex v0 = fromBufferDeviceAddresses(node.vertexBufferAddress, node.indexBufferAddress, 0);
	Vertex v1 = fromBufferDeviceAddresses(node.vertexBufferAddress, node.indexBufferAddress, 1);
	Vertex v2 = fromBufferDeviceAddresses(node.vertexBufferAddress, node.indexBufferAddress, 2);

	vec2 uv = (1.0 - attribs.x - attribs.y) * v0.texCoord + attribs.x * v1.texCoord + attribs.y * v2.texCoord;

    vec4 albedoWithAlpha = texture(textures[nonuniformEXT(mat.albedoIndex)], uv);
    if (albedoWithAlpha.a < 0.5)
    {
        ignoreIntersectionEXT; // alpha cutout
    }
}