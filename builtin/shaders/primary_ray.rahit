#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : require

#include "resources/camera_block.glsl"
#include "lib/bda_raytracing.glsl"
#include "lib/texture.glsl"
#include "lib/raytracing_utils.glsl"
#include "lib/visibility_buffer_utils.glsl" // For using the same texture LOD calculation method as visibility buffer

layout(set = 3, binding = 0) uniform accelerationStructureEXT topLevelAS;

struct GPUInstanceData {
    uint geometryOffset;
    uint geometryCount;
    uint materialOffset;
    uint materialCount;
};
layout(std430, set = 2, binding = 0) readonly buffer InstanceData { GPUInstanceData instances[]; };

#define GPU_MATERIAL_SET 2
#define GPU_MATERIAL_BINDING 1
#include "resources/gpu_material.glsl"
struct GPUGeometryNode {
    uint64_t vertexBufferAddress;
    uint64_t indexBufferAddress;
    uint materialIndex;
};

layout(std430, set = 2, binding = 2) readonly buffer GeometryNodes { GPUGeometryNode geometryNodes[]; };

layout(set = 2, binding = 3) uniform sampler2D textures[];

hitAttributeEXT vec2 attribs;

void main()
{
    const uint instanceIndex = gl_InstanceCustomIndexEXT;
    GPUInstanceData instance = instances[nonuniformEXT(instanceIndex)];

	const uint geomIndex = gl_GeometryIndexEXT;
    const uint geomGlobalIndex = instance.geometryOffset + geomIndex;
    GPUGeometryNode node = geometryNodes[nonuniformEXT(geomGlobalIndex)];

    const uint materialIndex = node.materialIndex;
    const uint materialGlobalIndex = instance.materialOffset + materialIndex;
    GPUMaterial mat = materials[nonuniformEXT(materialGlobalIndex)];

	Vertex v0 = fromBufferDeviceAddresses(node.vertexBufferAddress, node.indexBufferAddress, 0);
	Vertex v1 = fromBufferDeviceAddresses(node.vertexBufferAddress, node.indexBufferAddress, 1);
	Vertex v2 = fromBufferDeviceAddresses(node.vertexBufferAddress, node.indexBufferAddress, 2);

	vec2 uv = (1.0 - attribs.x - attribs.y) * v0.texCoord + attribs.x * v1.texCoord + attribs.y * v2.texCoord;

    // Calculate LOD by using partial derivatives of barycentric coordinates as in visibility buffer
    vec2 screenPosNDC = getNDC(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, vec2(0.0));
    vec2 textureDimensions = vec2(textureSize(textures[nonuniformEXT(mat.albedoIndex)], 0));
    mat3x2 texCoords = mat3x2(v0.texCoord, v1.texCoord, v2.texCoord);
    vec2 twoOverWindowSize = 2.0 / u_Camera.resolution;
    vec4 pt0 = u_Camera.viewProjection * vec4(v0.position, 1.0);
    vec4 pt1 = u_Camera.viewProjection * vec4(v1.position, 1.0);
    vec4 pt2 = u_Camera.viewProjection * vec4(v2.position, 1.0);

    BarycentricDeriv derivativesOut = CalcFullBary(pt0, pt1, pt2, screenPosNDC, twoOverWindowSize);
    GradientInterpolationResults results = Interpolate2DWithDeriv(derivativesOut, texCoords);
    // float lod = calculateMipLevelsGL(results.dx, results.dy, textureDimensions);
    vec2 duvdx = results.dx;
    vec2 duvdy = results.dy;

    vec4 albedoWithAlpha = textureGrad(textures[nonuniformEXT(mat.albedoIndex)], uv, duvdx, duvdy);
    if (albedoWithAlpha.a < 0.5)
    {
        ignoreIntersectionEXT; // alpha cutout
    }
}